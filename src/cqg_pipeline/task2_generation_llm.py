"""\nTask 2 Generation Module: Generate follow-up questions using fused understanding\n"""\n\nimport logging\nimport re\nfrom typing import List, Dict\n\nlogger = logging.getLogger(__name__)\n\n\nclass GenerationModuleLLM:\n    """Generate follow-up questions using fused knowledge"""\n    \n    def __init__(self, llm_client):\n        """Initialize with LLM client"""\n        self.llm_client = llm_client\n        self.logger = logging.getLogger(__name__)\n    \n    def generate_followups(\n        self,\n        cluster_action: str,\n        topics: List[str],\n        concepts: Dict[str, List[str]],\n        fused_understanding: str,\n        qa_pairs: List[Dict],\n        max_followups: int = 3\n    ) -> List[Dict]:\n        """\n        Generate diverse follow-up questions.\n        \n        Args:\n            cluster_action: Action label\n            topics: Extracted topics FROM QA PAIRS\n            concepts: Selected concepts\n            fused_understanding: Output from Fusion module\n            qa_pairs: Real QA data\n            max_followups: Max questions\n        \n        Returns:\n            List of dicts with questions\n        """\n        \n        topics_str = ', '.join(topics[:5])\n        qa_context = self._format_qas(qa_pairs)\n        \n        prompt = f"""You are generating DEEP follow-up questions for analysts.\n\nYour outputs MUST:\n- require domain knowledge to answer\n- reference hidden mechanisms or failure modes\n- be grounded in Q&A evidence OR concepts from fusion\n- drive investigation, not just ask obvious questions\n\nContext:\nCluster: {cluster_action}\nTopics: {topics_str}\n\nFused Knowledge:\n{fused_understanding}\n\nQ&A Context:\n{qa_context}\n\nGenerate 3 questions:\n\nQUESTION 1 — ROOT CAUSE DEPTH:\nAsk about upstream/systemic causes that require analysis of backend systems,\nreconciliation processes, or customer behavior patterns.\nThis must involve multi-hop reasoning.\n\nQUESTION 2 — QUANT/IMPACT ANALYSIS:\nAsk a question that requires measuring a business/operational metric\n(e.g., churn, SLA breach, refund processing time variations,\nfrequency of backend delays).\nIt must be answerable by data analysis.\n\nQUESTION 3 — PATTERN / SCENARIO DISCOVERY:\nAsk about conditional situations:\n"When X and Y happen together, does Z increase?"\nShould require correlational / pattern mining logic.\n\nFORMATTING:\nReturn them as:\n\nQUESTION_1:\n...\n\nQUESTION_2:\n...\n\nQUESTION_3:\n...\n"""\n        \n        response = self.llm_client.generate_text(\n            prompt,\n            max_tokens=400,\n            temperature=0.6\n        )\n        \n        self.logger.info(f"Raw LLM Response:\\n{response}")\n        \n        # Parse questions\n        followups = self._parse_questions(response)\n        \n        self.logger.info(f"Generated {len(followups)} follow-up questions")\n        \n        return followups[:max_followups]\n    \n    def _format_qas(self, qa_pairs: List[Dict]) -> str:\n        """Format QA pairs for prompt"""\n        \n        qa_text = ""\n        for i, qa in enumerate(qa_pairs[:2], 1):\n            q = qa.get('query', '')\n            a = qa.get('response', '')\n            if len(a) > 100:\n                a = a[:100] + "..."\n            qa_text += f"Q{i}: {q}\\nA{i}: {a}\\n\\n"\n        \n        return qa_text if qa_text else "No additional context"\n    \n    def _parse_questions(self, response: str) -> List[Dict]:\n        """Extract follow-up questions from response"""\n        \n        questions = []\n        \n        # Find questions after QUESTION_N: markers\n        pattern = r'QUESTION_\\d+:\\s*(.+?)(?=QUESTION_\\d+:|$)'\n        matches = re.findall(pattern, response, re.DOTALL)\n        \n        categories = ['causal', 'impact', 'pattern']\n        \n        for i, match in enumerate(matches[:3]):\n            lines = match.strip().split('\\n')\n            \n            # Find first non-empty line that looks like a question\n            for line in lines:\n                q = line.strip()\n                \n                # Validate\n                if not q or len(q) < 10:\n                    continue\n                if '?' not in q:\n                    continue\n                if len(q.split()) > 75:\n                    continue\n                \n                # Clean up\n                q = re.sub(r'^\\[.*?\\]\\s*', '', q)\n                q = q.strip()\n                \n                questions.append({\n                    'question': q,\n                    'category': categories[i] if i < len(categories) else 'other',\n                    'sequence': i + 1\n                })\n                \n                break\n        \n        return questions[:3]\n