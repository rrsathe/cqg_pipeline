"""\nTask 2 Recognition Module (REVISED): Extract topics from QA pairs\n\nNOT from clusters - extract directly from Q&A content\nfor cleaner, more reliable topic extraction\n"""\n\nimport logging\nimport re\nfrom typing import List, Dict\nfrom collections import Counter\n\nlogger = logging.getLogger(__name__)\n\n\nclass RecognitionModule:\n    """Extract key topics from QA pairs (not clusters)"""\n    \n    def __init__(self):\n        """Initialize recognition module"""\n        self.logger = logging.getLogger(__name__)\n    \n    def extract_topics_from_qas(\n        self,\n        qa_pairs: List[Dict],\n        cluster_action: str = None\n    ) -> List[str]:\n        """\n        Extract topics directly from QA pairs.\n        \n        REVISED: Uses QA content, not cluster data\n        \n        Args:\n            qa_pairs: QA pairs from other team\n            cluster_action: Optional action label for context\n        \n        Returns:\n            List of topic strings, sorted by importance\n        """\n        \n        topics = {}\n        \n        # 1. Extract from queries (questions asked)\n        for qa in qa_pairs:\n            query = qa.get('query', '').lower()\n            \n            # Extract noun phrases\n            words = re.findall(r'\\b[a-z]{4,}\\b', query)\n            \n            # Filter stop words\n            stop_words = {\n                'what', 'when', 'where', 'which', 'why', 'how',\n                'does', 'have', 'been', 'really', 'would', 'could',\n                'should', 'could', 'must', 'likely', 'often'\n            }\n            \n            words = [w for w in words if w not in stop_words]\n            \n            # Count frequency\n            for word in words[:5]:  # Top 5 words per query\n                if word not in topics:\n                    topics[word] = {'query_count': 0, 'response_count': 0}\n                topics[word]['query_count'] += 1\n        \n        # 2. Extract from responses (answers provided)\n        for qa in qa_pairs:\n            response = qa.get('response', '').lower()\n            \n            # Extract noun phrases and key terms\n            words = re.findall(r'\\b[a-z]{4,}\\b', response)\n            \n            # Filter more aggressively for responses\n            stop_words = {\n                'from', 'have', 'been', 'when', 'where', 'which',\n                'reason', 'caused', 'because', 'result', 'outcome',\n                'percent', 'percentage', 'time', 'days', 'hours',\n                'includes', 'involves', 'related', 'based'\n            }\n            \n            words = [w for w in words if w not in stop_words]\n            \n            # Count frequency\n            for word in words[:5]:  # Top 5 words per response\n                if word not in topics:\n                    topics[word] = {'query_count': 0, 'response_count': 0}\n                topics[word]['response_count'] += 1\n        \n        # 3. Add cluster action if provided\n        if cluster_action:\n            action = cluster_action.lower().strip()\n            if action not in topics:\n                topics[action] = {'query_count': 2, 'response_count': 2}\n            else:\n                topics[action]['query_count'] += 2\n                topics[action]['response_count'] += 2\n        \n        # 4. Score topics by combined frequency\n        scored_topics = []\n        for topic, counts in topics.items():\n            total_count = counts['query_count'] + counts['response_count']\n            score = (counts['query_count'] * 0.6) + (counts['response_count'] * 0.4)\n            \n            scored_topics.append({\n                'topic': topic,\n                'score': score,\n                'total_count': total_count\n            })\n        \n        # Sort by score and return top topics\n        sorted_topics = sorted(scored_topics, key=lambda x: x['score'], reverse=True)\n        result = [t['topic'] for t in sorted_topics[:8]]\n        \n        self.logger.info(f"Extracted {len(result)} topics from QA pairs: {result}")\n        \n        return result\n    \n    def extract_key_phrases_from_qas(\n        self,\n        qa_pairs: List[Dict]\n    ) -> List[str]:\n        """\n        Extract multi-word key phrases from QA pairs.\n        \n        More sophisticated approach using n-grams.\n        \n        Args:\n            qa_pairs: QA pairs from other team\n        \n        Returns:\n            List of key phrases (2-3 words)\n        """\n        \n        phrases = Counter()\n        \n        for qa in qa_pairs:\n            query = qa.get('query', '').lower()\n            response = qa.get('response', '')[:200].lower()  # First 200 chars\n            \n            combined = query + " " + response\n            \n            # Find 2-3 word phrases\n            words = re.findall(r'\\b[a-z]{3,}\\b', combined)\n            \n            for i in range(len(words) - 1):\n                phrase = f"{words[i]} {words[i+1]}"\n                phrases[phrase] += 1\n            \n            if len(words) > 2:\n                for i in range(len(words) - 2):\n                    phrase = f"{words[i]} {words[i+1]} {words[i+2]}"\n                    phrases[phrase] += 1\n        \n        # Return top phrases\n        top_phrases = [phrase for phrase, _ in phrases.most_common(5)]\n        \n        return top_phrases\n